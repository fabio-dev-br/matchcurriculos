{"remainingRequest":"/home/daniel/Desktop/Git/FrontEnd/node_modules/babel-loader/lib/index.js!/home/daniel/Desktop/Git/FrontEnd/node_modules/cache-loader/dist/cjs.js??ref--0-0!/home/daniel/Desktop/Git/FrontEnd/node_modules/vue-loader/lib/index.js??vue-loader-options!/home/daniel/Desktop/Git/FrontEnd/node_modules/@voerro/vue-tagsinput/src/VoerroTagsInput.vue?vue&type=script&lang=js&","dependencies":[{"path":"/home/daniel/Desktop/Git/FrontEnd/node_modules/@voerro/vue-tagsinput/src/VoerroTagsInput.vue","mtime":499162500000},{"path":"/home/daniel/Desktop/Git/FrontEnd/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/daniel/Desktop/Git/FrontEnd/node_modules/babel-loader/lib/index.js","mtime":499162500000},{"path":"/home/daniel/Desktop/Git/FrontEnd/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/daniel/Desktop/Git/FrontEnd/node_modules/vue-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":["import \"core-js/modules/es6.array.find\";\nimport \"core-js/modules/es7.symbol.async-iterator\";\nimport \"core-js/modules/es6.symbol\";\nimport \"core-js/modules/web.dom.iterable\";\nimport \"core-js/modules/es6.regexp.split\";\nimport \"core-js/modules/es6.array.sort\";\nimport \"core-js/modules/es6.regexp.search\";\nimport \"core-js/modules/es6.regexp.replace\";\nimport \"core-js/modules/es6.number.constructor\";\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\nexport default {\n  props: {\n    elementId: String,\n    existingTags: {\n      type: Object,\n      default: function _default() {\n        return {};\n      }\n    },\n    value: {\n      type: [Array, String],\n      default: function _default() {\n        return [];\n      }\n    },\n    typeahead: {\n      type: Boolean,\n      default: false\n    },\n    typeaheadStyle: {\n      type: String,\n      default: 'badges'\n    },\n    typeaheadActivationThreshold: {\n      type: Number,\n      default: 1\n    },\n    typeaheadMaxResults: {\n      type: Number,\n      default: 0\n    },\n    placeholder: {\n      type: String,\n      default: 'Add a tag'\n    },\n    limit: {\n      type: Number,\n      default: 0\n    },\n    onlyExistingTags: {\n      type: Boolean,\n      default: false\n    },\n    deleteOnBackspace: {\n      type: Boolean,\n      default: true\n    },\n    allowDuplicates: {\n      type: Boolean,\n      default: false\n    },\n    validate: {\n      type: Function,\n      default: function _default() {\n        return true;\n      }\n    },\n    addTagsOnComma: {\n      type: Boolean,\n      default: false\n    },\n    wrapperClass: {\n      type: String,\n      default: 'tags-input-wrapper-default'\n    }\n  },\n  data: function data() {\n    return {\n      badgeId: 0,\n      tagBadges: [],\n      tags: [],\n      input: '',\n      oldInput: '',\n      hiddenInput: '',\n      searchResults: [],\n      searchSelection: 0\n    };\n  },\n  created: function created() {\n    this.tagsFromValue(); // Emit an event\n\n    this.$emit('initialized');\n  },\n  watch: {\n    tags: function tags() {\n      // Updating the hidden input\n      this.hiddenInput = this.tags.join(','); // Update the bound v-model value\n\n      this.$emit('input', this.tags);\n    },\n    value: function value() {\n      this.tagsFromValue();\n    }\n  },\n  methods: {\n    escapeRegExp: function escapeRegExp(string) {\n      return string.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n    },\n    tagFromInput: function tagFromInput() {\n      // If we're choosing a tag from the search results\n      if (this.searchResults.length && this.searchSelection >= 0) {\n        this.tagFromSearch(this.searchResults[this.searchSelection]);\n        this.input = '';\n      } else {\n        // If we're adding an unexisting tag\n        var text = this.input.trim(); // If the new tag is not an empty string and passes validation\n\n        if (!this.onlyExistingTags && text.length && this.validate(text)) {\n          this.input = ''; // Determine the tag's slug and text depending on if the tag exists\n          // on the site already or not\n\n          var slug = this.makeSlug(text);\n          var existingTag = this.existingTags[slug];\n          slug = existingTag ? slug : text;\n          text = existingTag ? existingTag : text;\n          this.addTag(slug, text);\n        }\n      }\n    },\n    tagFromSearchOnClick: function tagFromSearchOnClick(tag) {\n      this.tagFromSearch(tag);\n      this.$refs['taginput'].blur();\n    },\n    tagFromSearch: function tagFromSearch(tag) {\n      this.searchResults = [];\n      this.input = '';\n      this.oldInput = '';\n      this.addTag(tag.slug, tag.text);\n    },\n    makeSlug: function makeSlug(value) {\n      return value.toLowerCase().replace(/\\s/g, '-');\n    },\n    addTag: function addTag(slug, text) {\n      // Check if the limit has been reached\n      if (this.limit > 0 && this.tags.length >= this.limit) {\n        return false;\n      } // Attach the tag if it hasn't been attached yet\n\n\n      if (!this.tagSelected(slug)) {\n        this.tagBadges.push(text.replace(/\\s/g, '&nbsp;'));\n        this.tags.push(slug);\n      } // Emit events\n\n\n      this.$emit('tag-added', slug);\n      this.$emit('tags-updated');\n    },\n    removeLastTag: function removeLastTag() {\n      if (!this.input.length && this.deleteOnBackspace) {\n        this.removeTag(this.tags.length - 1);\n      }\n    },\n    removeTag: function removeTag(index) {\n      var slug = this.tags[index];\n      this.tags.splice(index, 1);\n      this.tagBadges.splice(index, 1); // Emit events\n\n      this.$emit('tag-removed', slug);\n      this.$emit('tags-updated');\n    },\n    searchTag: function searchTag() {\n      if (this.typeahead === true) {\n        if (this.oldInput != this.input || !this.searchResults.length && this.typeaheadActivationThreshold == 0) {\n          this.searchResults = [];\n          this.searchSelection = 0;\n          var input = this.input.trim();\n\n          if (input.length && input.length >= this.typeaheadActivationThreshold || this.typeaheadActivationThreshold == 0) {\n            for (var slug in this.existingTags) {\n              var text = this.existingTags[slug].toLowerCase();\n\n              if (text.search(this.escapeRegExp(input.toLowerCase())) > -1 && !this.tagSelected(slug)) {\n                this.searchResults.push({\n                  slug: slug,\n                  text: this.existingTags[slug]\n                });\n              }\n            } // Sort the search results alphabetically\n\n\n            this.searchResults.sort(function (a, b) {\n              if (a.text < b.text) return -1;\n              if (a.text > b.text) return 1;\n              return 0;\n            }); // Shorten Search results to desired length\n\n            if (this.typeaheadMaxResults > 0) {\n              this.searchResults = this.searchResults.slice(0, this.typeaheadMaxResults);\n            }\n          }\n\n          this.oldInput = this.input;\n        }\n      }\n    },\n    onFocus: function onFocus() {\n      this.searchTag();\n    },\n    hideTypeahead: function hideTypeahead() {\n      var _this = this;\n\n      if (!this.input.length) {\n        this.$nextTick(function () {\n          _this.ignoreSearchResults();\n        });\n      }\n    },\n    nextSearchResult: function nextSearchResult() {\n      if (this.searchSelection + 1 <= this.searchResults.length - 1) {\n        this.searchSelection++;\n      }\n    },\n    prevSearchResult: function prevSearchResult() {\n      if (this.searchSelection > 0) {\n        this.searchSelection--;\n      }\n    },\n    ignoreSearchResults: function ignoreSearchResults() {\n      this.searchResults = [];\n      this.searchSelection = 0;\n    },\n\n    /**\n    * Clear the list of selected tags\n    */\n    clearTags: function clearTags() {\n      this.tags.splice(0, this.tags.length);\n      this.tagBadges.splice(0, this.tagBadges.length);\n    },\n\n    /**\n    * Replace the currently selected tags with the tags from the value\n    */\n    tagsFromValue: function tagsFromValue() {\n      if (this.value && this.value.length) {\n        var tags = Array.isArray(this.value) ? this.value : this.value.split(',');\n\n        if (this.tags == tags) {\n          return;\n        }\n\n        this.clearTags();\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n          for (var _iterator = tags[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var slug = _step.value;\n            var existingTag = this.existingTags[slug];\n            var text = existingTag ? existingTag : slug;\n            this.addTag(slug, text);\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return != null) {\n              _iterator.return();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n      } else {\n        if (this.tags.length == 0) {\n          return;\n        }\n\n        this.clearTags();\n      }\n    },\n\n    /**\n    * Check if the tag with the provided slug is already selected\n    */\n    tagSelected: function tagSelected(slug) {\n      var _this2 = this;\n\n      if (this.allowDuplicates) {\n        return false;\n      }\n\n      if (!slug) {\n        return false;\n      }\n\n      var searchSlug = this.makeSlug(slug);\n      var found = this.tags.find(function (value) {\n        return searchSlug == _this2.makeSlug(value);\n      });\n      return !!found;\n    },\n\n    /**\n     * Process all the keydown events\n     */\n    onKeyDown: function onKeyDown(e) {\n      // Insert a new tag on comma keydown if the option is enabled\n      if (e.key == ',') {\n        if (this.addTagsOnComma) {\n          // The comma shouldn't actually be inserted\n          e.preventDefault(); // Add the inputed tag\n\n          this.tagFromInput();\n        }\n      }\n    }\n  }\n};",{"version":3,"sources":["VoerroTagsInput.vue"],"names":[],"mappings":"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","sourcesContent":["<template>\n    <div class=\"tags-input-root\">\n        <div :class=\"wrapperClass + ' tags-input'\">\n            <span class=\"tags-input-badge tags-input-badge-pill tags-input-badge-selected-default\"\n                v-for=\"(badge, index) in tagBadges\"\n                :key=\"index\"\n            >\n                <span v-html=\"badge\"></span>\n\n                <i href=\"#\" class=\"tags-input-remove\" @click.prevent=\"removeTag(index)\"></i>\n            </span>\n\n            <input type=\"text\"\n                ref=\"taginput\"\n                :placeholder=\"placeholder\"\n                v-model=\"input\"\n                @keydown.enter.prevent=\"tagFromInput\"\n                @keydown.8=\"removeLastTag\"\n                @keydown.down=\"nextSearchResult\"\n                @keydown.up=\"prevSearchResult\"\n                @keydown=\"onKeyDown\"\n                @keyup.esc=\"ignoreSearchResults\"\n                @keyup=\"searchTag\"\n                @focus=\"onFocus\"\n                @blur=\"hideTypeahead\"\n                @value=\"tags\">\n\n            <input type=\"hidden\" v-if=\"elementId\"\n                :name=\"elementId\"\n                :id=\"elementId\"\n                v-model=\"hiddenInput\">\n        </div>\n\n        <!-- Typeahead/Autocomplete -->\n        <div v-show=\"searchResults.length\">\n            <p v-if=\"typeaheadStyle === 'badges'\" :class=\"`typeahead-${typeaheadStyle}`\">\n                <span v-for=\"(tag, index) in searchResults\"\n                    :key=\"index\"\n                    v-text=\"tag.text\"\n                    @mouseover=\"searchSelection = index\"\n                    @mousedown.prevent=\"tagFromSearchOnClick(tag)\"\n                    class=\"tags-input-badge\"\n                    v-bind:class=\"{\n                        'tags-input-typeahead-item-default': index != searchSelection,\n                        'tags-input-typeahead-item-highlighted-default': index == searchSelection\n                    }\"></span>\n            </p>\n\n            <ul v-else-if=\"typeaheadStyle === 'dropdown'\" :class=\"`typeahead-${typeaheadStyle}`\">\n                <li v-for=\"(tag, index) in searchResults\"\n                :key=\"index\"\n                v-text=\"tag.text\"\n                @mouseover=\"searchSelection = index\"\n                @mousedown.prevent=\"tagFromSearchOnClick(tag)\"\n                v-bind:class=\"{\n                    'tags-input-typeahead-item-default': index != searchSelection,\n                    'tags-input-typeahead-item-highlighted-default': index == searchSelection\n                }\"></li>\n            </ul>\n        </div>\n    </div>\n</template>\n\n<script>\nexport default {\n    props: {\n        elementId: String,\n\n        existingTags: {\n            type: Object,\n            default: () => {\n                return {};\n            }\n        },\n\n        value: {\n            type: [Array, String],\n            default: () => {\n                return [];\n            }\n        },\n\n        typeahead: {\n            type: Boolean,\n            default: false\n        },\n\n        typeaheadStyle: {\n            type: String,\n            default: 'badges'\n        },\n\n        typeaheadActivationThreshold: {\n            type: Number,\n            default: 1\n        },\n\n        typeaheadMaxResults: {\n            type: Number,\n            default: 0\n        },\n\n        placeholder: {\n            type: String,\n            default: 'Add a tag'\n        },\n\n        limit: {\n            type: Number,\n            default: 0\n        },\n\n        onlyExistingTags: {\n            type: Boolean,\n            default: false\n        },\n\n        deleteOnBackspace: {\n            type: Boolean,\n            default: true\n        },\n\n        allowDuplicates: {\n            type: Boolean,\n            default: false\n        },\n        \n        validate: {\n            type: Function,\n            default: () => true\n        },\n\n        addTagsOnComma: {\n            type: Boolean,\n            default: false\n        },\n\n        wrapperClass: {\n            type: String,\n            default: 'tags-input-wrapper-default'\n        },\n    },\n\n    data() {\n        return {\n            badgeId: 0,\n            tagBadges: [],\n            tags: [],\n\n            input: '',\n            oldInput: '',\n            hiddenInput: '',\n\n            searchResults: [],\n            searchSelection: 0,\n        };\n    },\n\n    created () {\n        this.tagsFromValue();\n\n        // Emit an event\n        this.$emit('initialized');\n    },\n\n    watch: {\n        tags() {\n            // Updating the hidden input\n            this.hiddenInput = this.tags.join(',');\n\n            // Update the bound v-model value\n            this.$emit('input', this.tags);\n        },\n\n        value() {\n            this.tagsFromValue();\n        }\n    },\n\n    methods: {\n        escapeRegExp(string) {\n            return string.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n        },\n\n        tagFromInput() {\n            // If we're choosing a tag from the search results\n            if (this.searchResults.length && this.searchSelection >= 0) {\n                this.tagFromSearch(this.searchResults[this.searchSelection]);\n\n                this.input = '';\n            } else {\n                // If we're adding an unexisting tag\n                let text = this.input.trim();\n\n                // If the new tag is not an empty string and passes validation\n                if (!this.onlyExistingTags && text.length && this.validate(text)) {\n                    this.input = '';\n\n                    // Determine the tag's slug and text depending on if the tag exists\n                    // on the site already or not\n                    let slug = this.makeSlug(text);\n                    let existingTag = this.existingTags[slug];\n\n                    slug = existingTag ? slug : text;\n                    text = existingTag ? existingTag : text;\n\n                    this.addTag(slug, text);\n                }\n            }\n        },\n\n        tagFromSearchOnClick(tag) {\n            this.tagFromSearch(tag);\n\n            this.$refs['taginput'].blur();\n        },\n\n        tagFromSearch(tag) {\n            this.searchResults = [];\n            this.input = '';\n            this.oldInput = '';\n\n            this.addTag(tag.slug, tag.text);\n        },\n\n        makeSlug(value) {\n            return value.toLowerCase().replace(/\\s/g, '-');\n        },\n\n        addTag(slug, text) {\n            // Check if the limit has been reached\n            if (this.limit > 0 && this.tags.length >= this.limit) {\n                return false;\n            }\n\n            // Attach the tag if it hasn't been attached yet\n            if (!this.tagSelected(slug)) {\n                this.tagBadges.push(text.replace(/\\s/g, '&nbsp;'));\n                this.tags.push(slug);\n            }\n\n            // Emit events\n            this.$emit('tag-added', slug);\n            this.$emit('tags-updated');\n        },\n\n        removeLastTag() {\n            if (!this.input.length && this.deleteOnBackspace) {\n                this.removeTag(this.tags.length - 1);\n            }\n        },\n\n        removeTag(index) {\n            let slug = this.tags[index];\n\n            this.tags.splice(index, 1);\n            this.tagBadges.splice(index, 1);\n\n            // Emit events\n            this.$emit('tag-removed', slug);\n            this.$emit('tags-updated');\n        },\n\n        searchTag() {\n            if (this.typeahead === true) {\n                if (this.oldInput != this.input || (!this.searchResults.length && this.typeaheadActivationThreshold == 0)) {\n                    this.searchResults = [];\n                    this.searchSelection = 0;\n                    let input = this.input.trim();\n\n                    if ((input.length && input.length >= this.typeaheadActivationThreshold) || this.typeaheadActivationThreshold == 0) {\n                        for (let slug in this.existingTags) {\n                            let text = this.existingTags[slug].toLowerCase();\n\n                            if (text.search(this.escapeRegExp(input.toLowerCase())) > -1 && ! this.tagSelected(slug)) {\n                                this.searchResults.push({ slug, text: this.existingTags[slug] });\n                            }\n                        }\n\n                        // Sort the search results alphabetically\n                        this.searchResults.sort((a, b) => {\n                            if (a.text < b.text) return -1;\n                            if (a.text > b.text) return 1;\n\n                            return 0;\n                        });\n\n                        // Shorten Search results to desired length\n                        if (this.typeaheadMaxResults > 0) {\n                            this.searchResults = this.searchResults.slice(\n                                0,\n                                this.typeaheadMaxResults\n                            );\n                        }\n                    }\n\n                    this.oldInput = this.input;\n                }\n            }\n        },\n\n        onFocus() {\n            this.searchTag();\n        },\n\n        hideTypeahead() {\n            if (! this.input.length) {\n                this.$nextTick(() => {\n                    this.ignoreSearchResults();\n                });\n            }\n        },\n\n        nextSearchResult() {\n            if (this.searchSelection + 1 <= this.searchResults.length - 1) {\n                this.searchSelection++;\n            }\n        },\n\n        prevSearchResult() {\n            if (this.searchSelection > 0) {\n                this.searchSelection--;\n            }\n        },\n\n        ignoreSearchResults() {\n            this.searchResults = [];\n            this.searchSelection = 0;\n        },\n\n        /**\n        * Clear the list of selected tags\n        */\n        clearTags() {\n            this.tags.splice(0, this.tags.length);\n            this.tagBadges.splice(0, this.tagBadges.length);\n        },\n\n        /**\n        * Replace the currently selected tags with the tags from the value\n        */\n        tagsFromValue() {\n            if (this.value && this.value.length) {\n                let tags = Array.isArray(this.value)\n                    ? this.value\n                    : this.value.split(',');\n\n                if (this.tags == tags) {\n                    return;\n                }\n\n                this.clearTags();\n\n                for (let slug of tags) {\n                    let existingTag = this.existingTags[slug];\n                    let text = existingTag ? existingTag : slug;\n\n                    this.addTag(slug, text);\n                }\n            } else {\n                if (this.tags.length == 0) {\n                    return;\n                }\n\n                this.clearTags();\n            }\n        },\n\n        /**\n        * Check if the tag with the provided slug is already selected\n        */\n        tagSelected(slug) {\n            if (this.allowDuplicates) {\n                return false;\n            }\n\n            if (! slug) {\n                return false;\n            }\n\n            let searchSlug = this.makeSlug(slug);\n            let found = this.tags.find((value) => {\n                return searchSlug == this.makeSlug(value);\n            });\n\n            return !! found;\n        },\n\n        /**\n         * Process all the keydown events\n         */\n        onKeyDown(e) {\n            // Insert a new tag on comma keydown if the option is enabled\n            if (e.key == ',') {\n                if (this.addTagsOnComma) {\n                    // The comma shouldn't actually be inserted\n                    e.preventDefault();\n\n                    // Add the inputed tag\n                    this.tagFromInput();\n                }\n            }\n        },\n    }\n}\n</script>\n\n<style>\n.tags-input-root {\n    position: relative;\n}\n</style>\n"],"sourceRoot":"node_modules/@voerro/vue-tagsinput/src"}]}