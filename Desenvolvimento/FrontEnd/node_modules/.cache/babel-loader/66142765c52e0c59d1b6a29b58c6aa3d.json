{"remainingRequest":"/home/daniel/Desktop/Git/FrontEnd/node_modules/babel-loader/lib/index.js!/home/daniel/Desktop/Git/FrontEnd/node_modules/vue-loader/lib/index.js??vue-loader-options!/home/daniel/Desktop/Git/FrontEnd/node_modules/@voerro/vue-tagsinput/src/VoerroTagsInput.vue?vue&type=script&lang=js&","dependencies":[{"path":"/home/daniel/Desktop/Git/FrontEnd/node_modules/@voerro/vue-tagsinput/src/VoerroTagsInput.vue","mtime":499162500000},{"path":"/home/daniel/Desktop/Git/FrontEnd/node_modules/cache-loader/dist/cjs.js","mtime":1543518246810},{"path":"/home/daniel/Desktop/Git/FrontEnd/node_modules/babel-loader/lib/index.js","mtime":1534881725000},{"path":"/home/daniel/Desktop/Git/FrontEnd/node_modules/vue-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":["import \"core-js/modules/es6.array.find\";\nimport \"core-js/modules/es7.symbol.async-iterator\";\nimport \"core-js/modules/es6.symbol\";\nimport \"core-js/modules/web.dom.iterable\";\nimport \"core-js/modules/es6.regexp.split\";\nimport \"core-js/modules/es6.array.sort\";\nimport \"core-js/modules/es6.regexp.search\";\nimport \"core-js/modules/es6.regexp.replace\";\nimport \"core-js/modules/es6.number.constructor\";\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\nexport default {\n  props: {\n    elementId: String,\n    inputClass: {\n      type: String,\n      default: 'tags-input-default-class'\n    },\n    existingTags: {\n      type: Object,\n      default: function _default() {\n        return {};\n      }\n    },\n    value: {\n      type: [Array, String],\n      default: function _default() {\n        return [];\n      }\n    },\n    typeahead: {\n      type: Boolean,\n      default: false\n    },\n    typeaheadActivationThreshold: {\n      type: Number,\n      default: 1\n    },\n    typeaheadMaxResults: {\n      type: Number,\n      default: 0\n    },\n    placeholder: {\n      type: String,\n      default: 'Add a tag'\n    },\n    limit: {\n      type: Number,\n      default: 0\n    },\n    onlyExistingTags: {\n      type: Boolean,\n      default: false\n    },\n    deleteOnBackspace: {\n      type: Boolean,\n      default: true\n    },\n    allowDuplicates: {\n      type: Boolean,\n      default: false\n    },\n    validate: {\n      type: Function,\n      default: function _default() {\n        return true;\n      }\n    }\n  },\n  data: function data() {\n    return {\n      badgeId: 0,\n      tagBadges: [],\n      tags: [],\n      input: '',\n      oldInput: '',\n      hiddenInput: '',\n      searchResults: [],\n      searchSelection: 0\n    };\n  },\n  created: function created() {\n    this.tagsFromValue();\n  },\n  watch: {\n    tags: function tags() {\n      // Updating the hidden input\n      this.hiddenInput = this.tags.join(','); // Update the bound v-model value\n\n      this.$emit('input', this.tags);\n    },\n    value: function value() {\n      this.tagsFromValue();\n    }\n  },\n  methods: {\n    escapeRegExp: function escapeRegExp(string) {\n      return string.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n    },\n    tagFromInput: function tagFromInput() {\n      // If we're choosing a tag from the search results\n      if (this.searchResults.length && this.searchSelection >= 0) {\n        this.tagFromSearch(this.searchResults[this.searchSelection]);\n        this.input = '';\n      } else {\n        // If we're adding an unexisting tag\n        var text = this.input.trim(); // If the new tag is not an empty string and passes validation\n\n        if (!this.onlyExistingTags && text.length && this.validate(text)) {\n          this.input = ''; // Determine the tag's slug and text depending on if the tag exists\n          // on the site already or not\n\n          var slug = this.makeSlug(text);\n          var existingTag = this.existingTags[slug];\n          slug = existingTag ? slug : text;\n          text = existingTag ? existingTag : text;\n          this.addTag(slug, text);\n        }\n      }\n    },\n    tagFromSearchOnClick: function tagFromSearchOnClick(tag) {\n      this.tagFromSearch(tag);\n      this.$refs['taginput'].blur();\n    },\n    tagFromSearch: function tagFromSearch(tag) {\n      this.searchResults = [];\n      this.input = '';\n      this.oldInput = '';\n      this.addTag(tag.slug, tag.text);\n    },\n    makeSlug: function makeSlug(value) {\n      return value.toLowerCase().replace(/\\s/g, '-');\n    },\n    addTag: function addTag(slug, text) {\n      // Check if the limit has been reached\n      if (this.limit > 0 && this.tags.length >= this.limit) {\n        return false;\n      } // Attach the tag if it hasn't been attached yet\n\n\n      if (!this.tagSelected(slug)) {\n        this.tagBadges.push(text.replace(/\\s/g, '&nbsp;'));\n        this.tags.push(slug);\n      }\n    },\n    removeLastTag: function removeLastTag() {\n      if (!this.input.length && this.deleteOnBackspace) {\n        this.removeTag(this.tags.length - 1);\n      }\n    },\n    removeTag: function removeTag(index) {\n      this.tags.splice(index, 1);\n      this.tagBadges.splice(index, 1);\n    },\n    searchTag: function searchTag() {\n      if (this.typeahead === true) {\n        if (this.oldInput != this.input || !this.searchResults.length && this.typeaheadActivationThreshold == 0) {\n          this.searchResults = [];\n          this.searchSelection = 0;\n          var input = this.input.trim();\n\n          if (input.length && input.length >= this.typeaheadActivationThreshold || this.typeaheadActivationThreshold == 0) {\n            for (var slug in this.existingTags) {\n              var text = this.existingTags[slug].toLowerCase();\n\n              if (text.search(this.escapeRegExp(input.toLowerCase())) > -1 && !this.tagSelected(slug)) {\n                this.searchResults.push({\n                  slug: slug,\n                  text: this.existingTags[slug]\n                });\n              }\n            } // Sort the search results alphabetically\n\n\n            this.searchResults.sort(function (a, b) {\n              if (a.text < b.text) return -1;\n              if (a.text > b.text) return 1;\n              return 0;\n            }); // Shorten Search results to desired length\n\n            if (this.typeaheadMaxResults > 0) {\n              this.searchResults = this.searchResults.slice(0, this.typeaheadMaxResults);\n            }\n          }\n\n          this.oldInput = this.input;\n        }\n      }\n    },\n    onFocus: function onFocus() {\n      this.searchTag();\n    },\n    hideTypeahead: function hideTypeahead() {\n      var _this = this;\n\n      if (!this.input.length) {\n        this.$nextTick(function () {\n          _this.ignoreSearchResults();\n        });\n      }\n    },\n    nextSearchResult: function nextSearchResult() {\n      if (this.searchSelection + 1 <= this.searchResults.length - 1) {\n        this.searchSelection++;\n      }\n    },\n    prevSearchResult: function prevSearchResult() {\n      if (this.searchSelection > 0) {\n        this.searchSelection--;\n      }\n    },\n    ignoreSearchResults: function ignoreSearchResults() {\n      this.searchResults = [];\n      this.searchSelection = 0;\n    },\n\n    /**\n    * Clear the list of selected tags\n    */\n    clearTags: function clearTags() {\n      this.tags.splice(0, this.tags.length);\n      this.tagBadges.splice(0, this.tagBadges.length);\n    },\n\n    /**\n    * Replace the currently selected tags with the tags from the value\n    */\n    tagsFromValue: function tagsFromValue() {\n      if (this.value && this.value.length) {\n        var tags = Array.isArray(this.value) ? this.value : this.value.split(',');\n\n        if (this.tags == tags) {\n          return;\n        }\n\n        this.clearTags();\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n          for (var _iterator = tags[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var slug = _step.value;\n            var existingTag = this.existingTags[slug];\n            var text = existingTag ? existingTag : slug;\n            this.addTag(slug, text);\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return != null) {\n              _iterator.return();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n      } else {\n        if (this.tags.length == 0) {\n          return;\n        }\n\n        this.clearTags();\n      }\n    },\n\n    /**\n    * Check if the tag with the provided slug is already selected\n    */\n    tagSelected: function tagSelected(slug) {\n      var _this2 = this;\n\n      if (this.allowDuplicates) {\n        return false;\n      }\n\n      if (!slug) {\n        return false;\n      }\n\n      var searchSlug = this.makeSlug(slug);\n      var found = this.tags.find(function (value) {\n        return searchSlug == _this2.makeSlug(value);\n      });\n      return !!found;\n    }\n  }\n};",{"version":3,"sources":["VoerroTagsInput.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA+CA,eAAA;AACA,SAAA;AACA,eAAA,MADA;AAGA,gBAAA;AACA,YAAA,MADA;AAEA,eAAA;AAFA,KAHA;AAQA,kBAAA;AACA,YAAA,MADA;AAEA,eAAA,oBAAA;AACA,eAAA,EAAA;AACA;AAJA,KARA;AAeA,WAAA;AACA,YAAA,CAAA,KAAA,EAAA,MAAA,CADA;AAEA,eAAA,oBAAA;AACA,eAAA,EAAA;AACA;AAJA,KAfA;AAsBA,eAAA;AACA,YAAA,OADA;AAEA,eAAA;AAFA,KAtBA;AA2BA,kCAAA;AACA,YAAA,MADA;AAEA,eAAA;AAFA,KA3BA;AAgCA,yBAAA;AACA,YAAA,MADA;AAEA,eAAA;AAFA,KAhCA;AAqCA,iBAAA;AACA,YAAA,MADA;AAEA,eAAA;AAFA,KArCA;AA0CA,WAAA;AACA,YAAA,MADA;AAEA,eAAA;AAFA,KA1CA;AA+CA,sBAAA;AACA,YAAA,OADA;AAEA,eAAA;AAFA,KA/CA;AAoDA,uBAAA;AACA,YAAA,OADA;AAEA,eAAA;AAFA,KApDA;AAyDA,qBAAA;AACA,YAAA,OADA;AAEA,eAAA;AAFA,KAzDA;AA8DA,cAAA;AACA,YAAA,QADA;AAEA,eAAA;AAAA,eAAA,IAAA;AAAA;AAFA;AA9DA,GADA;AAqEA,MArEA,kBAqEA;AACA,WAAA;AACA,eAAA,CADA;AAEA,iBAAA,EAFA;AAGA,YAAA,EAHA;AAKA,aAAA,EALA;AAMA,gBAAA,EANA;AAOA,mBAAA,EAPA;AASA,qBAAA,EATA;AAUA,uBAAA;AAVA,KAAA;AAYA,GAlFA;AAoFA,SApFA,qBAoFA;AACA,SAAA,aAAA;AACA,GAtFA;AAwFA,SAAA;AACA,QADA,kBACA;AACA;AACA,WAAA,WAAA,GAAA,KAAA,IAAA,CAAA,IAAA,CAAA,GAAA,CAAA,CAFA,CAIA;;AACA,WAAA,KAAA,CAAA,OAAA,EAAA,KAAA,IAAA;AACA,KAPA;AASA,SATA,mBASA;AACA,WAAA,aAAA;AACA;AAXA,GAxFA;AAsGA,WAAA;AACA,gBADA,wBACA,MADA,EACA;AACA,aAAA,OAAA,OAAA,CAAA,qBAAA,EAAA,MAAA,CAAA;AACA,KAHA;AAKA,gBALA,0BAKA;AACA;AACA,UAAA,KAAA,aAAA,CAAA,MAAA,IAAA,KAAA,eAAA,IAAA,CAAA,EAAA;AACA,aAAA,aAAA,CAAA,KAAA,aAAA,CAAA,KAAA,eAAA,CAAA;AAEA,aAAA,KAAA,GAAA,EAAA;AACA,OAJA,MAIA;AACA;AACA,YAAA,OAAA,KAAA,KAAA,CAAA,IAAA,EAAA,CAFA,CAIA;;AACA,YAAA,CAAA,KAAA,gBAAA,IAAA,KAAA,MAAA,IAAA,KAAA,QAAA,CAAA,IAAA,CAAA,EAAA;AACA,eAAA,KAAA,GAAA,EAAA,CADA,CAGA;AACA;;AACA,cAAA,OAAA,KAAA,QAAA,CAAA,IAAA,CAAA;AACA,cAAA,cAAA,KAAA,YAAA,CAAA,IAAA,CAAA;AAEA,iBAAA,cAAA,IAAA,GAAA,IAAA;AACA,iBAAA,cAAA,WAAA,GAAA,IAAA;AAEA,eAAA,MAAA,CAAA,IAAA,EAAA,IAAA;AACA;AACA;AACA,KA9BA;AAgCA,wBAhCA,gCAgCA,GAhCA,EAgCA;AACA,WAAA,aAAA,CAAA,GAAA;AAEA,WAAA,KAAA,CAAA,UAAA,EAAA,IAAA;AACA,KApCA;AAsCA,iBAtCA,yBAsCA,GAtCA,EAsCA;AACA,WAAA,aAAA,GAAA,EAAA;AACA,WAAA,KAAA,GAAA,EAAA;AACA,WAAA,QAAA,GAAA,EAAA;AAEA,WAAA,MAAA,CAAA,IAAA,IAAA,EAAA,IAAA,IAAA;AACA,KA5CA;AA8CA,YA9CA,oBA8CA,KA9CA,EA8CA;AACA,aAAA,MAAA,WAAA,GAAA,OAAA,CAAA,KAAA,EAAA,GAAA,CAAA;AACA,KAhDA;AAkDA,UAlDA,kBAkDA,IAlDA,EAkDA,IAlDA,EAkDA;AACA;AACA,UAAA,KAAA,KAAA,GAAA,CAAA,IAAA,KAAA,IAAA,CAAA,MAAA,IAAA,KAAA,KAAA,EAAA;AACA,eAAA,KAAA;AACA,OAJA,CAMA;;;AACA,UAAA,CAAA,KAAA,WAAA,CAAA,IAAA,CAAA,EAAA;AACA,aAAA,SAAA,CAAA,IAAA,CAAA,KAAA,OAAA,CAAA,KAAA,EAAA,QAAA,CAAA;AACA,aAAA,IAAA,CAAA,IAAA,CAAA,IAAA;AACA;AACA,KA7DA;AA+DA,iBA/DA,2BA+DA;AACA,UAAA,CAAA,KAAA,KAAA,CAAA,MAAA,IAAA,KAAA,iBAAA,EAAA;AACA,aAAA,SAAA,CAAA,KAAA,IAAA,CAAA,MAAA,GAAA,CAAA;AACA;AACA,KAnEA;AAqEA,aArEA,qBAqEA,KArEA,EAqEA;AACA,WAAA,IAAA,CAAA,MAAA,CAAA,KAAA,EAAA,CAAA;AACA,WAAA,SAAA,CAAA,MAAA,CAAA,KAAA,EAAA,CAAA;AACA,KAxEA;AA0EA,aA1EA,uBA0EA;AACA,UAAA,KAAA,SAAA,KAAA,IAAA,EAAA;AACA,YAAA,KAAA,QAAA,IAAA,KAAA,KAAA,IAAA,CAAA,KAAA,aAAA,CAAA,MAAA,IAAA,KAAA,4BAAA,IAAA,CAAA,EAAA;AACA,eAAA,aAAA,GAAA,EAAA;AACA,eAAA,eAAA,GAAA,CAAA;AACA,cAAA,QAAA,KAAA,KAAA,CAAA,IAAA,EAAA;;AAEA,cAAA,MAAA,MAAA,IAAA,MAAA,MAAA,IAAA,KAAA,4BAAA,IAAA,KAAA,4BAAA,IAAA,CAAA,EAAA;AACA,iBAAA,IAAA,IAAA,IAAA,KAAA,YAAA,EAAA;AACA,kBAAA,OAAA,KAAA,YAAA,CAAA,IAAA,EAAA,WAAA,EAAA;;AAEA,kBAAA,KAAA,MAAA,CAAA,KAAA,YAAA,CAAA,MAAA,WAAA,EAAA,CAAA,IAAA,CAAA,CAAA,IAAA,CAAA,KAAA,WAAA,CAAA,IAAA,CAAA,EAAA;AACA,qBAAA,aAAA,CAAA,IAAA,CAAA;AAAA,4BAAA;AAAA,wBAAA,KAAA,YAAA,CAAA,IAAA;AAAA,iBAAA;AACA;AACA,aAPA,CASA;;;AACA,iBAAA,aAAA,CAAA,IAAA,CAAA,UAAA,CAAA,EAAA,CAAA,EAAA;AACA,kBAAA,EAAA,IAAA,GAAA,EAAA,IAAA,EAAA,OAAA,CAAA,CAAA;AACA,kBAAA,EAAA,IAAA,GAAA,EAAA,IAAA,EAAA,OAAA,CAAA;AAEA,qBAAA,CAAA;AACA,aALA,EAVA,CAiBA;;AACA,gBAAA,KAAA,mBAAA,GAAA,CAAA,EAAA;AACA,mBAAA,aAAA,GAAA,KAAA,aAAA,CAAA,KAAA,CACA,CADA,EAEA,KAAA,mBAFA,CAAA;AAIA;AACA;;AAEA,eAAA,QAAA,GAAA,KAAA,KAAA;AACA;AACA;AACA,KA9GA;AAgHA,WAhHA,qBAgHA;AACA,WAAA,SAAA;AACA,KAlHA;AAoHA,iBApHA,2BAoHA;AAAA;;AACA,UAAA,CAAA,KAAA,KAAA,CAAA,MAAA,EAAA;AACA,aAAA,SAAA,CAAA,YAAA;AACA,gBAAA,mBAAA;AACA,SAFA;AAGA;AACA,KA1HA;AA4HA,oBA5HA,8BA4HA;AACA,UAAA,KAAA,eAAA,GAAA,CAAA,IAAA,KAAA,aAAA,CAAA,MAAA,GAAA,CAAA,EAAA;AACA,aAAA,eAAA;AACA;AACA,KAhIA;AAkIA,oBAlIA,8BAkIA;AACA,UAAA,KAAA,eAAA,GAAA,CAAA,EAAA;AACA,aAAA,eAAA;AACA;AACA,KAtIA;AAwIA,uBAxIA,iCAwIA;AACA,WAAA,aAAA,GAAA,EAAA;AACA,WAAA,eAAA,GAAA,CAAA;AACA,KA3IA;;AA6IA;;;AAGA,aAhJA,uBAgJA;AACA,WAAA,IAAA,CAAA,MAAA,CAAA,CAAA,EAAA,KAAA,IAAA,CAAA,MAAA;AACA,WAAA,SAAA,CAAA,MAAA,CAAA,CAAA,EAAA,KAAA,SAAA,CAAA,MAAA;AACA,KAnJA;;AAqJA;;;AAGA,iBAxJA,2BAwJA;AACA,UAAA,KAAA,KAAA,IAAA,KAAA,KAAA,CAAA,MAAA,EAAA;AACA,YAAA,OAAA,MAAA,OAAA,CAAA,KAAA,KAAA,IACA,KAAA,KADA,GAEA,KAAA,KAAA,CAAA,KAAA,CAAA,GAAA,CAFA;;AAIA,YAAA,KAAA,IAAA,IAAA,IAAA,EAAA;AACA;AACA;;AAEA,aAAA,SAAA;AATA;AAAA;AAAA;;AAAA;AAWA,+BAAA,IAAA,8HAAA;AAAA,gBAAA,IAAA;AACA,gBAAA,cAAA,KAAA,YAAA,CAAA,IAAA,CAAA;AACA,gBAAA,OAAA,cAAA,WAAA,GAAA,IAAA;AAEA,iBAAA,MAAA,CAAA,IAAA,EAAA,IAAA;AACA;AAhBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAiBA,OAjBA,MAiBA;AACA,YAAA,KAAA,IAAA,CAAA,MAAA,IAAA,CAAA,EAAA;AACA;AACA;;AAEA,aAAA,SAAA;AACA;AACA,KAjLA;;AAmLA;;;AAGA,eAtLA,uBAsLA,IAtLA,EAsLA;AAAA;;AACA,UAAA,KAAA,eAAA,EAAA;AACA,eAAA,KAAA;AACA;;AAEA,UAAA,CAAA,IAAA,EAAA;AACA,eAAA,KAAA;AACA;;AAEA,UAAA,aAAA,KAAA,QAAA,CAAA,IAAA,CAAA;AACA,UAAA,QAAA,KAAA,IAAA,CAAA,IAAA,CAAA,UAAA,KAAA,EAAA;AACA,eAAA,cAAA,OAAA,QAAA,CAAA,KAAA,CAAA;AACA,OAFA,CAAA;AAIA,aAAA,CAAA,CAAA,KAAA;AACA;AArMA;AAtGA,CAAA","sourcesContent":["<template>\n    <div>\n        <div :class=\"inputClass + ' tags-input'\">\n            <span class=\"badge badge-pill badge-light\"\n                v-for=\"(badge, index) in tagBadges\"\n                :key=\"index\"\n            >\n                <span v-html=\"badge\"></span>\n\n                <i href=\"#\" class=\"tags-input-remove\" @click.prevent=\"removeTag(index)\"></i>\n            </span>\n\n            <input type=\"text\"\n                ref=\"taginput\"\n                :placeholder=\"placeholder\"\n                v-model=\"input\"\n                @keydown.enter.prevent=\"tagFromInput\"\n                @keydown.8=\"removeLastTag\"\n                @keydown.down=\"nextSearchResult\"\n                @keydown.up=\"prevSearchResult\"\n                @keyup.esc=\"ignoreSearchResults\"\n                @keyup=\"searchTag\"\n                @focus=\"onFocus\"\n                @blur=\"hideTypeahead\"\n                @value=\"tags\">\n\n            <input type=\"hidden\" v-if=\"elementId\"\n                :name=\"elementId\"\n                :id=\"elementId\"\n                v-model=\"hiddenInput\">\n        </div>\n\n        <p v-show=\"searchResults.length\" class=\"typeahead\">\n            <span v-for=\"(tag, index) in searchResults\"\n                :key=\"index\"\n                v-text=\"tag.text\"\n                @mousedown.prevent=\"tagFromSearchOnClick(tag)\"\n                class=\"badge\"\n                v-bind:class=\"{\n                    'badge-primary': index == searchSelection,\n                    'badge-dark': index != searchSelection\n                }\"></span>\n        </p>\n    </div>\n</template>\n\n<script>\nexport default {\n    props: {\n        elementId: String,\n\n        inputClass: {\n            type: String,\n            default: 'tags-input-default-class'\n        },\n\n        existingTags: {\n            type: Object,\n            default: () => {\n                return {};\n            }\n        },\n\n        value: {\n            type: [Array, String],\n            default: () => {\n                return [];\n            }\n        },\n\n        typeahead: {\n            type: Boolean,\n            default: false\n        },\n\n        typeaheadActivationThreshold: {\n            type: Number,\n            default: 1\n        },\n\n        typeaheadMaxResults: {\n            type: Number,\n            default: 0\n        },\n\n        placeholder: {\n            type: String,\n            default: 'Add a tag'\n        },\n\n        limit: {\n            type: Number,\n            default: 0\n        },\n\n        onlyExistingTags: {\n            type: Boolean,\n            default: false\n        },\n\n        deleteOnBackspace: {\n            type: Boolean,\n            default: true\n        },\n\n        allowDuplicates: {\n            type: Boolean,\n            default: false\n        },\n        \n        validate: {\n            type: Function,\n            default: () => true\n        }\n    },\n\n    data() {\n        return {\n            badgeId: 0,\n            tagBadges: [],\n            tags: [],\n\n            input: '',\n            oldInput: '',\n            hiddenInput: '',\n\n            searchResults: [],\n            searchSelection: 0,\n        };\n    },\n\n    created () {\n        this.tagsFromValue();\n    },\n\n    watch: {\n        tags() {\n            // Updating the hidden input\n            this.hiddenInput = this.tags.join(',');\n\n            // Update the bound v-model value\n            this.$emit('input', this.tags);\n        },\n\n        value() {\n            this.tagsFromValue();\n        }\n    },\n\n    methods: {\n        escapeRegExp(string) {\n            return string.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n        },\n\n        tagFromInput() {\n            // If we're choosing a tag from the search results\n            if (this.searchResults.length && this.searchSelection >= 0) {\n                this.tagFromSearch(this.searchResults[this.searchSelection]);\n\n                this.input = '';\n            } else {\n                // If we're adding an unexisting tag\n                let text = this.input.trim();\n\n                // If the new tag is not an empty string and passes validation\n                if (!this.onlyExistingTags && text.length && this.validate(text)) {\n                    this.input = '';\n\n                    // Determine the tag's slug and text depending on if the tag exists\n                    // on the site already or not\n                    let slug = this.makeSlug(text);\n                    let existingTag = this.existingTags[slug];\n\n                    slug = existingTag ? slug : text;\n                    text = existingTag ? existingTag : text;\n\n                    this.addTag(slug, text);\n                }\n            }\n        },\n\n        tagFromSearchOnClick(tag) {\n            this.tagFromSearch(tag);\n\n            this.$refs['taginput'].blur();\n        },\n\n        tagFromSearch(tag) {\n            this.searchResults = [];\n            this.input = '';\n            this.oldInput = '';\n\n            this.addTag(tag.slug, tag.text);\n        },\n\n        makeSlug(value) {\n            return value.toLowerCase().replace(/\\s/g, '-');\n        },\n\n        addTag(slug, text) {\n            // Check if the limit has been reached\n            if (this.limit > 0 && this.tags.length >= this.limit) {\n                return false;\n            }\n\n            // Attach the tag if it hasn't been attached yet\n            if (!this.tagSelected(slug)) {\n                this.tagBadges.push(text.replace(/\\s/g, '&nbsp;'));\n                this.tags.push(slug);\n            }\n        },\n\n        removeLastTag() {\n            if (!this.input.length && this.deleteOnBackspace) {\n                this.removeTag(this.tags.length - 1);\n            }\n        },\n\n        removeTag(index) {\n            this.tags.splice(index, 1);\n            this.tagBadges.splice(index, 1);\n        },\n\n        searchTag() {\n            if (this.typeahead === true) {\n                if (this.oldInput != this.input || (!this.searchResults.length && this.typeaheadActivationThreshold == 0)) {\n                    this.searchResults = [];\n                    this.searchSelection = 0;\n                    let input = this.input.trim();\n\n                    if ((input.length && input.length >= this.typeaheadActivationThreshold) || this.typeaheadActivationThreshold == 0) {\n                        for (let slug in this.existingTags) {\n                            let text = this.existingTags[slug].toLowerCase();\n\n                            if (text.search(this.escapeRegExp(input.toLowerCase())) > -1 && ! this.tagSelected(slug)) {\n                                this.searchResults.push({ slug, text: this.existingTags[slug] });\n                            }\n                        }\n\n                        // Sort the search results alphabetically\n                        this.searchResults.sort((a, b) => {\n                            if (a.text < b.text) return -1;\n                            if (a.text > b.text) return 1;\n\n                            return 0;\n                        });\n\n                        // Shorten Search results to desired length\n                        if (this.typeaheadMaxResults > 0) {\n                            this.searchResults = this.searchResults.slice(\n                                0,\n                                this.typeaheadMaxResults\n                            );\n                        }\n                    }\n\n                    this.oldInput = this.input;\n                }\n            }\n        },\n\n        onFocus() {\n            this.searchTag();\n        },\n\n        hideTypeahead() {\n            if (! this.input.length) {\n                this.$nextTick(() => {\n                    this.ignoreSearchResults();\n                });\n            }\n        },\n\n        nextSearchResult() {\n            if (this.searchSelection + 1 <= this.searchResults.length - 1) {\n                this.searchSelection++;\n            }\n        },\n\n        prevSearchResult() {\n            if (this.searchSelection > 0) {\n                this.searchSelection--;\n            }\n        },\n\n        ignoreSearchResults() {\n            this.searchResults = [];\n            this.searchSelection = 0;\n        },\n\n        /**\n        * Clear the list of selected tags\n        */\n        clearTags() {\n            this.tags.splice(0, this.tags.length);\n            this.tagBadges.splice(0, this.tagBadges.length);\n        },\n\n        /**\n        * Replace the currently selected tags with the tags from the value\n        */\n        tagsFromValue() {\n            if (this.value && this.value.length) {\n                let tags = Array.isArray(this.value)\n                    ? this.value\n                    : this.value.split(',');\n\n                if (this.tags == tags) {\n                    return;\n                }\n\n                this.clearTags();\n\n                for (let slug of tags) {\n                    let existingTag = this.existingTags[slug];\n                    let text = existingTag ? existingTag : slug;\n\n                    this.addTag(slug, text);\n                }\n            } else {\n                if (this.tags.length == 0) {\n                    return;\n                }\n\n                this.clearTags();\n            }\n        },\n\n        /**\n        * Check if the tag with the provided slug is already selected\n        */\n        tagSelected(slug) {\n            if (this.allowDuplicates) {\n                return false;\n            }\n\n            if (! slug) {\n                return false;\n            }\n\n            let searchSlug = this.makeSlug(slug);\n            let found = this.tags.find((value) => {\n                return searchSlug == this.makeSlug(value);\n            });\n\n            return !! found;\n        }\n    }\n}\n</script>\n\n<style>\n/* tags-input */\n.tags-input {\n    display: flex;\n    flex-wrap: wrap;\n    align-items: center;\n}\n\n.tags-input input {\n    flex: 1;\n    background: transparent;\n    border: none;\n}\n\n.tags-input span {\n    margin-right: 0.3rem;\n    margin-bottom: 0.2rem;\n}\n\n.typeahead > span {\n    cursor: pointer;\n    margin-right: 0.3rem;\n}\n</style>\n"],"sourceRoot":"node_modules/@voerro/vue-tagsinput/src"}]}